<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Département Électronique – B2MS CleanTech</title>
  <link rel="stylesheet" href="style-commun.css" />

</head>
<body>
  <header>
    <h1>Département Électronique – B2MS CleanTech</h1>
  </header>

  <nav class="main-nav">
    <a href="index.html"><button>Accueil</button></a>
    <a href="it.html"><button>IT</button></a>
    <button class="tab-button active" data-target="electronique-content">Electronique</button>
    <a href="mecanique.html"><button>Mécanique</button></a>
    <a href="mecatronique.html"><button>Mécatronique</button></a>
  </nav>

  <section id="electronique-content" class="tab-content active">
    <nav class="subnav">
      <button class="subtab-button active" data-target="test1">Projet 1</button>
      <button class="subtab-button" data-target="test2">Projet 2</button>
      <button class="subtab-button" data-target="test3">Projet 3</button>
    </nav>

    <div id="test1" class="subtab-content active">
      <h2>Projet Gyroscope et Accéléromètre MPU6050</h2>
        <h3>1. Contexte et objectifs:</h3>
          <p>
            Les données de navigation telles que la direction et l'accélération sont essentielles dans la conception d’un robot.
            Ce projet utilise un module MPU6050, combinant un gyroscope et un accéléromètre, pour mesurer l’orientation et les mouvements.
          </p>
          <p>
            Ce projet a pour objectif de :
          </p>
          <ul>
            <li>Comprendre le fonctionnement d’un capteur inertiel (IMU).</li>
            <li>afficher en temps réel les directions (haut, bas, gauche, droite) ainsi que les données d’accélération sur un écran LCD.</li>
            <li>Utiliser le protocole de communication I2C.</li>
            <li>Appliquer les bonnes pratiques de conception logicielle (structure modulaire, classes bien définies, etc.).</li>
          </ul>

          <h3>2. Choix du capteur : MPU6050</h3>

          <p>
           Le <strong>MPU6050</strong> est un capteur IMU (Inertial Measurement Unit) 6 axes qui combine :
            <ul>
            <li>Un accéléromètre 3 axes</li>
            <li>Un gyroscope 3 axes</li>
            </ul>
          </p>
        
          <p>
            Il utilise une interface I2C, parfaitement compatible avec les
            microcontrôleurs comme l’Arduino, ce qui facilite la lecture des
            données avec un minimum de fils et une consommation réduite.
          </p>

          <p>
            Il est largement utilisé dans la communauté Arduino, avec de
            nombreuses bibliothèques disponibles (comme MPU6050.h ou
            Wire.h), ce qui simplifie le développement et le débogage
          </p>

          <p>
          <strong>Caractéristiques principales</strong> : <a href="https://invensense.tdk.com/wp-content/uploads/2015/02/MPU-6000-Datasheet1.pdf" download class="download-link">datasheet du MPU6050</a>
            <ul>
            <li>Interface I2C (adresse par défaut : `0x68`)</li>
            <li>Plage de mesure accéléromètre : ±2g, ±4g, ±8g, ±16g</li>
            <li>Tension d’alimentation : 3.3V – 5V</li>
            </ul>
            
          </p>
          

        <h3>3. Principe de fonctionnement</h3>
            <p>
             Le capteur MPU6050 combine deux fonctions principales : un accéléromètre et un gyroscope.
            L’accéléromètre permet de mesurer l’accélération linéaire sur les trois axes (X, Y, Z), ce qui
            permet de détecter les mouvements de la main vers le haut, le bas, la gauche, la droite, l’avant
            ou l’arrière. De son côté, le gyroscope mesure la vitesse angulaire sur ces mêmes axes, ce qui
            permet de connaître l’orientation de la main, comme une inclinaison ou une rotation.
          </p>

          <p>
           Pour transmettre les données au microcontrôleur, le MPU6050 utilise le protocole de
            communication I2C. Ce protocole est simple et efficace, car il ne nécessite que deux fils : la
            ligne SCL (pour l’horloge) et la ligne SDA (pour les données). Grâce à cette liaison, le
            microcontrôleur peut envoyer des commandes au capteur et lire ses valeurs en temps réel.
          </p>

          <p>
           Pour que le MPU6050 envoie les données, il ne suffit pas
          de simplement le connecter. Étant donné qu’on utilise
          une communication I2C, il faut suivre un protocole bien
          défini :
          </p>

          <h4>a. Envoi d’une commande au capteur</h4>
  
            <p>
            Avant de lire une donnée, l’Arduino doit envoyer l’adresse du registre souhaité. Cette adresse indique quel type de
              donnée on veut (accélération, vitesse angulaire)
            </p>

            <div class="image-container">
              <img src="images/Test1/Electronique/registre_electronique1.png" alt="Registre" class="image-centree" />
            </div>
            <div class="image-container">
              <img src="images/Test1/Electronique/registre_electronique2.png" alt="Registre" class="image-centree" />
            </div>

          <h4>b.  Structure des données reçues</h4>

            <p>
              Chaque mesure (accélération ou rotation) est codée sur 16 bits (2 octets) :  
            </p>
              <ul>
              <li>8 bits MSB (poids fort)</li>
              <li>8 bits LSB (poids faible)</li>
            </ul> 
            <p>
              Les valeurs sont en complément à deux (signed integer), ce qui permet d'indiquer un sens positif ou négatif du mouvement. 
            </p>

          <h4>c. Conversion des données brutes</h4>
  
            <p>
            Pour exploiter les mesures, il faut les convertir en unités physiques :
            </p>
            <ul>
              <li> Accélération en g (gravité terrestre)</li>
              <li> Rotation en °/s (degrés par seconde)</li>
            </ul> 

            <div class="image-container">
              <img src="images/Test1/Electronique/converesion_electro1.png" alt="Conversion" class="image-centree" />
            </div>
            <div class="image-container">
              <img src="images/Test1/Electronique/converesion_electro2.png" alt="Conversion" class="image-centree" />
            </div>

          
          <h3>4. Schéma électronique sous KICAD</h3>
          <div class="image-container">
            <img src="images/Test1/Electronique/schema_electro.png" alt="Schéma électronique sous KICAD" class="image-centree" />
          </div>

          <h3>
            5. Codage : <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Code/tree/29c205f31917e11acc9b94ef01549ebb94ee7ca4/Test1/Electronique" download class="download-link">lien vers les codes</a>
          </h3> 
          <h4>a. Code 1: </h4> 
            <p>
              Ce code utilise les librairies existantes sur Arduino IDE.
            </p>
          <div class="image-container">
            <img src="images/Test1/Electronique/code1a.png" alt="Code" class="image-small" />
            <img src="images/Test1/Electronique/code1b.png" alt="Code" class="image-small" />
            <img src="images/Test1/Electronique/code1c.png" alt="Code" class="image-small" />
          </div>

          <h4>a. Code 2: </h4> 
            <p>
              Ce code n'utilise pas les librairies existantes sur Arduino IDE pour le capteur.
            </p>
            <div class="image-container">
            <img src="images/Test1/Electronique/code2a.png" alt="Code" class="image-small" />
            <img src="images/Test1/Electronique/code2b.png" alt="Code" class="image-small" />
            <img src="images/Test1/Electronique/code2c.png" alt="Code" class="image-small" />
            <img src="images/Test1/Electronique/code2d.png" alt="Code" class="image-small" />
            <img src="images/Test1/Electronique/code2e.png" alt="Code" class="image-small" />
          </div>


          <h3>6. Conception d'un prototype et démonstration</h3>
          <ul>
              <li> 
                <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/tree/e5c868a970dbb57e96550918782e5e32cda997c2/images/Test1/Electronique" download class="download-link">lien vers les images</a>
             </li>
              <li>
                <a href="https://github.com/TekBot-Robotics-Challenge/2025-Team-B2MS_CleanTech-Docs/tree/e5c868a970dbb57e96550918782e5e32cda997c2/videos/Test1/Electronique" download class="download-link">lien vers les vidéos</a>
              </li>
            </ul> 
          
          <div class="image-container">
            <img src="images/Test1/Electronique/electronique1.jpg" alt="Prototype" class="image-small" />
            <img src="images/Test1/Electronique/electronique2.jpg" alt="Prototype" class="image-small" />
            <img src="images/Test1/Electronique/electronique3.jpg" alt="Prototype" class="image-small" />
            <img src="images/Test1/Electronique/electronique4.jpg" alt="Prototype" class="image-small" />
          </div>

          <video controls width=auto>
            <source src="videos/Test1/Electronique/final_trial.mp4" type="video/mp4">
            Votre navigateur ne supporte pas la vidéo HTML5.
          </video>

          <video controls width=auto>
            <source src="videos/Test1/Electronique/prototype.mp4" type="video/mp4">
            Votre navigateur ne supporte pas la vidéo HTML5.
          </video>

          <h3>7. Remarques</h3>
            <ul>
            <li>
              Pour des lectures plus stables et précises, il est possible d'intégrer
              un filtre complémentaire ou un filtre de Kalman.</li>
            <li>
              Ce projet constitue une excellente base pour des systèmes plus avancés,
              tels que les contrôleurs, les robots auto-équilibrés ou les plateformes de stabilisation.</li>
          </ul> 
          
    
        <h3>8. Conclusion</h3>
          <p>
            Ce projet nous a permis d’explorer l’intégration d’un capteur inertiel dans un système embarqué, ainsi que de mettre en œuvre la détection
            et l’affichage en temps réel des mouvements de la main.
          </p>
           
          <p>
            Le module MPU6050 s’est révélé être un outil efficace et accessible
            pour la détection de l’orientation et des mouvements.
          </p>

          <p>
            Grâce à sa compatibilité avec l’écosystème Arduino et à la disponibilité de bibliothèques
            dédiées, le MPU6050 peut être facilement intégré dans divers projets éducatifs ou de prototypage.
          </p>

          <p>
            L’affichage des directions détectées et des valeurs d’accélération sur un écran LCD 16x2
            offre une visualisation claire et pédagogique, idéale pour l’apprentissage des capteurs,
            de la programmation de microcontrôleurs et des interfaces homme-machine.
          </p>      
          
          <p>
            Au-delà de son intérêt pédagogique, ce système peut être étendu à des applications telles
            que le contrôle par gestes, la réalité virtuelle ou la robotique, avec la possibilité
            d’ajouter une communication Bluetooth ou Wi-Fi pour renforcer l’interactivité.
          </p>      


    </div>

    <div id="test2" class="subtab-content">
      <h2>Test 2</h2>
      
      <p>Contenu du Test 2 :</p>
    </div>

    <div id="test3" class="subtab-content">
      <h2>Test 3</h2>
      <p>Contenu du Test 3 :</p>
    </div>
  </section>

  <footer>
    Copyright © 2025 Team B2MS CleanTech. All rights reserved.
  </footer>

  <script>
    // Onglets principaux (IT, Electronique, ...)
    document.querySelectorAll(".tab-button").forEach(button => {
      button.addEventListener("click", e => {
        document.querySelectorAll(".tab-button").forEach(btn => btn.classList.remove("active"));
        e.currentTarget.classList.add("active");

        // Afficher le contenu lié (ici, uniquement IT est en page unique)
        document.querySelectorAll(".tab-content").forEach(tc => tc.classList.remove("active"));

        const target = e.currentTarget.getAttribute("data-target");
        if (target) {
          document.getElementById(target).classList.add("active");
        }
      });
    });

    // Sous-onglets (Test 1, 2, 3)
    document.querySelectorAll(".subtab-button").forEach(button => {
      button.addEventListener("click", e => {
        const parent = e.currentTarget.closest(".tab-content");

        parent.querySelectorAll(".subtab-button").forEach(btn => btn.classList.remove("active"));
        e.currentTarget.classList.add("active");

        parent.querySelectorAll(".subtab-content").forEach(content => content.classList.remove("active"));
        const target = e.currentTarget.getAttribute("data-target");
        parent.querySelector("#" + target).classList.add("active");
      });
    });
  </script>
</body>
</html>
